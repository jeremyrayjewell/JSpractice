<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="pseudostyles.css">
    <title>Sorting Algorithms Explained</title>
</head>
<body>
    <div class="options">
      <h1>Sorting Algorithms Explained</h1><br>
      <p>Examples in Pseudocode</p><br>
    </div>
    <div class="bubbleSort">
        <h3>Bubble Sort</h3><br>
        <ul>
            <li>Bubble sort works by repeatedly stepping through the list to be sorted, comparing each pair of adjacent items, and swapping them if they are in the wrong order.</li>
            <li>It continues this process until no more swaps are needed, indicating that the list is sorted.
            </li>
        </ul>
        <code>
    function bubbleSort(arr):
        n = length(arr)
        for i from 0 to n-1:
            for j from 0 to n-1-i:
                if arr[j] > arr[j+1]:
                    swap(arr[j], arr[j+1])
        return arr
        </code>
    </div>
    <div class="selectionSort">
        <h3>Selection Sort</h3><br>
        <ul>
            <li>Selection sort divides the input list into two parts: the sorted part and the unsorted part.
            </li>
            <li>It repeatedly finds the minimum element from the unsorted part and swaps it with the first element of the unsorted part.
            </li>
            <li>This process continues until the entire list is sorted.
            </li>
        </ul>
        <code>
    function selectionSort(arr):
        n = length(arr)
        for i from 0 to n-1:
            minIndex = i
            for j from i+1 to n-1:
                if arr[j] < arr[minIndex]:
                    minIndex = j
            swap(arr[i], arr[minIndex])
        return arr
        </code>
    </div>
    <div class="mergeSort">
        <h3>Merge Sort</h3><br>
        <ul>
            <li>Merge sort is a divide-and-conquer algorithm that divides the input list into smaller halves until each sub-list contains only one element (considered sorted).
            </li>
            <li>It then merges these sub-lists back together by comparing and merging elements in sorted order until a single sorted list is obtained.
            </li>
        </ul>
        <code>
    function mergeSort(arr):
        if length(arr) <= 1:
        return arr
    
        mid = length(arr) / 2
        left = arr[0 to mid-1]
        right = arr[mid to end]

        left = mergeSort(left)
        right = mergeSort(right)

        return merge(left, right)

    function merge(left, right):
        result = []
        while left is not empty and right is not empty:
            if left[0] <= right[0]:
                result.append(left[0])
                left = left[1:]
            else:
                result.append(right[0])
                right = right[1:]
    
        if left is not empty:
            result.extend(left)
    
        if right is not empty:
            result.extend(right)
    
        return result
        </code>
    </div>
    <div class="quickSort">
        <h3>Quick Sort</h3><br>
        <ul>
            <li>Quick sort also uses a divide-and-conquer approach but chooses a "pivot" element from the list.
            </li>
            <li>It partitions the list into two sub-lists: elements less than the pivot and elements greater than the pivot.
            </li>
            <li>It recursively sorts these sub-lists and combines them to produce a sorted list.
            </li>
        </ul>
        <code>
    function quickSort(arr):
        if length(arr) <= 1:
            return arr
    
        pivot = arr[choosePivotIndex(arr)]
        left = []
        right = []

        for element in arr:
            if element < pivot:
                left.append(element)
            else if element > pivot:
                right.append(element)
    
        left = quickSort(left)
        right = quickSort(right)

        return left + [pivot] + right

    function choosePivotIndex(arr):
        // Choose a pivot index (e.g., first, last, median-of-three, etc.)
        // Implement your choice here
        </code>
    </div>
    <div class="insertionSort">
        <h3>Insertion Sort</h3><br>
        <ul>
            <li>Insertion sort builds the final sorted list one item at a time.
            </li>
            <li>It takes each element from the unsorted part and inserts it into its correct position in the sorted part of the list.
            </li>
            <li>This process continues until the entire list is sorted.
            </li>
        </ul>
        <code>
    function insertionSort(arr):
        n = length(arr)
        for i from 1 to n-1:
            key = arr[i]
            j = i - 1
            while j >= 0 and arr[j] > key:
                arr[j+1] = arr[j]
                j = j - 1
            arr[j+1] = key
        return arr        
        </code>
    </div>
    <div class="heapSort">
        <h3>Heap Sort</h3><br>
        <ul>
            <li>Heap sort is based on the binary heap data structure, which is a complete binary tree where each parent node is greater (for max heap) or smaller (for min heap) than its children.
            </li>
            <li>It builds a heap from the input list, ensuring that the largest (or smallest) element is at the root.
            </li>
            <li>It repeatedly removes the root element and replaces it with the last element in the heap, then restores the heap property.
            </li>
            <li>This process continues until the entire list is sorted.
            </li>
        </ul>
        <code>
    function heapSort(arr):
        buildMaxHeap(arr)
        n = length(arr)
        
        for i from n-1 to 0:
            swap(arr[0], arr[i])
            maxHeapify(arr, 0, i)
        
    function buildMaxHeap(arr):
        n = length(arr)
        for i from floor(n/2) - 1 to 0:
            maxHeapify(arr, i, n)
        
    function maxHeapify(arr, i, n):
        largest = i
        left = 2*i + 1
        right = 2*i + 2
        
        if left < n and arr[left] > arr[largest]:
            largest = left
        
        if right < n and arr[right] > arr[largest]:
            largest = right
        
        if largest != i:
            swap(arr[i], arr[largest])
            maxHeapify(arr, largest, n)        
        </code>
    </div>
</body>
</html>